use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
use std::{sync::mpsc, thread, error::Error};
use thiserror::Error;

use crate::{frame::manager::FrameManager, keycapture::KeyCaptureManager, state::{CommandToExecute, EditorMode, State}, Config};



pub struct Application {
    configuration: Config,
    editor: Editor,
}

#[derive(Default)]
struct Editor {
    frames: FrameManager,
    state: State,
}

#[derive(Error)]
enum EditorError {
    #[error("Invalid mode switch: {0}")]
    InvalidmodeSwitch(ModeSwitch)
}

enum EditorAction {
    ModeSwitch(EditorMode),
    Action(KeyMode),
    ModifyBuffer(KeyEvent),
}

impl Editor {
    fn start(&mut self) -> Result<(), Box<dyn Error>> {
        let (sender, receiver) = mpsc::channel();

        let key_capture = KeyCaptureManager::new(sender.clone());
        thread::spawn(move || key_capture.start());
        loop {
            let keyevent: KeyEvent = receiver.recv()?;
            let result: EditorAction = self.parse_keyevent(keyevent)?;
            dbg!(result);
        }

        Ok(())
    }

    fn parse_keyevent(&mut self, key: KeyEvent) -> Result<EditorAction, Box<dyn Error>> {
        if let Some(mode_switch_request) = self.editor_mode_switching(&key) {
            let validated = self.validate_request_mode_switch(&mode_switch_request);
            if !validated {
              Ok(EditorAction::Action(key))
            } else {
              Ok(EditorAction::ModeSwitch(mode_switch_request))
            }
        }
        Ok(EditorAction::ModifyBuffer(key))
    }

    /// Returns if the key event wants to switch the editor
    fn editor_mode_switching(&self, key: &KeyEvent) -> Option<EditorMode> {
        if !key.modifiers.is_empty() {
            return None;
        }

        match key.code {
            KeyCode::Esc => Some(EditorMode::Normal),
            KeyCode::Char('i') => Some(EditorMode::Insert),
            KeyCode::Char('v') => {
                let cursor_pos = self.frames.cursor_position();

                Some(EditorMode::Visual(crate::state::VisualModeKind::normal_at(cursor_pos)))
            },
            KeyCode::Char(':') => Some(EditorMode::Command(CommandToExecute::default())),
            _ => None
        }
    }

    fn validate_request_mode_switch(&self, mode: &EditorMode) -> bool {
        match (self.state.get_mode(), mode) {
            (EditorMode::Normal, EditorMode::Insert) => true,
            (EditorMode::Normal, EditorMode::Visual { .. }) => true,
            (EditorMode::Normal, EditorMode::Command(_)) => true,
            (EditorMode::Insert, EditorMode::Normal) => true,
            (EditorMode::Visual { .. }, EditorMode::Normal) => true,
            (EditorMode::Command(_), EditorMode::Normal) => true,
            _ => false
        }
    }
}


pub enum ApplicationEvent {
    KeyPress(KeyEvent),
    ConfigurationReload
}

impl Application {
    pub fn new() -> Self {
        Application {
            editor: Editor::default(),
            configuration: Config::default(),
        }
    }

    pub fn start(&mut self) -> Result<(), Box<dyn Error>> {
        self.editor.start()
    }

    fn render(&self) {}

    //fn input_manager(&mut self, event: KeyEvent) {



        // let action = self.get_action(&event.key);
        //
        // match action {
        //     Action::RequestModeSwitch(req) => {
        //         let output = Application::validate_request_mode_switch(self.state.get_mode(), &req);
        //
        //         dbg!(output, req);
        //     },
        //     Action::BindingAttempt(binding) => {
        //         dbg!(binding);
        //     },
        //     Action::Key(key) => {
        //         match self.state.get_mode() {
        //             EditorMode::Normal | EditorMode::Visual { .. } => {
        //                 self.command_buffer.append(key);
        //             },
        //             EditorMode::Insert => {
        //                 self.frames.send_input(key);
        //             },
        //             EditorMode::Command(char) => {
        //                 dbg!(char);
        //                 println!("Command mode");
        //             }
        //         };
        //     }
        // };
    //}

    // fn validate_request_mode_switch(current_mode: &EditorMode, new_mode: &EditorMode) -> bool {
    //     match (current_mode, new_mode) {
    //         (EditorMode::Normal, EditorMode::Insert) => true,
    //         (EditorMode::Normal, EditorMode::Visual { .. }) => true,
    //         (EditorMode::Normal, EditorMode::Command(_)) => true,
    //         (EditorMode::Insert, EditorMode::Normal) => true,
    //         (EditorMode::Visual { .. }, EditorMode::Normal) => true,
    //         (EditorMode::Command(_), EditorMode::Normal) => true,
    //         _ => false
    //     }
    // }
    //
    // fn get_action(&self, code: &KeyCode) -> Action {
    //     match code {
    //         KeyCode::Esc => Action::RequestModeSwitch(EditorMode::Normal),
    //         KeyCode::Char('i') => Action::RequestModeSwitch(EditorMode::Insert),
    //         KeyCode::Char('v') => Action::RequestModeSwitch(EditorMode::Visual {
    //             // TODO: Detta
    //             selection_start: (0, 0),
    //             selection_end: (0, 0)
    //         }),
    //         KeyCode::Char(':') => Action::RequestModeSwitch(EditorMode::Command(CommandToExecute::default())),
    //         KeyCode::Char(c) => Action::Key(*c),
    //         _ => Action::BindingAttempt(KeyBind {
    //             key: *code,
    //             modifiers: KeyModifiers::empty()
    //         })
    //     }
    // }
}

#[derive(Debug)]
struct KeyBind {
    key: KeyCode,
    modifiers: KeyModifiers,
}

#[derive(Debug)]
enum Action {
    RequestModeSwitch(EditorMode),
    BindingAttempt(KeyBind),
    Key(char)
}
