use crossterm::event::{KeyCode, KeyEvent};
use std::{thread, sync::mpsc, error::Error as StdError};
use crate::{frame::manager::FrameManager, keycapture::KeyCaptureManager, state::{CommandToExecute, EditorMode, State}};
use thiserror::Error;

#[derive(Default)]
pub struct Editor {
    frames: FrameManager,
    state: State,
}

#[derive(Debug)]
enum EditorAction {
    ModeSwitch(EditorMode),
    Action(KeyEvent),
    ModifyBuffer(KeyEvent),
    ModifyCommand(KeyEvent),
}

impl Editor {
    pub fn start(&mut self) -> Result<(), Box<dyn StdError>> {
        let (sender, receiver) = mpsc::channel();

        let key_capture = KeyCaptureManager::new(sender.clone());
        thread::spawn(move || key_capture.start());
        loop {
            let keyevent: KeyEvent = receiver.recv()?;
            let result = self.parse_keyevent(keyevent)?;

            match result {
                EditorAction::ModeSwitch(mode) => {
                  self.state.set_mode(mode);
                },
                EditorAction::ModifyBuffer(key) => {
                  self.frames.send_input(key);
                },
                EditorAction::Action(key) => {
                    unimplemented!();
                },
                EditorAction::ModifyCommand(key) => {
                  unimplemented!();
                }
            };
        }
    }

    fn parse_keyevent(&mut self, key: KeyEvent) -> Result<EditorAction, Box<dyn StdError>> {
        if key.code == KeyCode::Esc {
            return Ok(EditorAction::ModeSwitch(EditorMode::Normal));
        }

        if *self.state.get_mode() == EditorMode::Insert {
            return Ok(EditorAction::ModifyBuffer(key));
        }

        if *self.state.get_mode() == EditorMode::Command {
            return Ok(EditorAction::ModifyCommand(key));
        }

        let mode_to_switch_if_valid = self.editor_mode_switching(&key);

        if let Some(mode_maybe_invalid) = mode_to_switch_if_valid {
           let validated = self.validate_request_mode_switch(&mode_maybe_invalid);
           if validated {
             return Ok(EditorAction::ModeSwitch(mode_maybe_invalid));
           } else {
             return Ok(EditorAction::Action(key));
           }
        }

        // TODO: Command mode
        return Ok(EditorAction::Action(key));
    }

    /// Returns if the key event wants to switch the editor
    fn editor_mode_switching(&self, key: &KeyEvent) -> Option<EditorMode> {
        if !key.modifiers.is_empty() {
            return None;
        }

        match key.code {
            KeyCode::Esc => Some(EditorMode::Normal),
            KeyCode::Char('i') => Some(EditorMode::Insert),
            KeyCode::Char('v') => {
                let cursor_pos = self.frames.cursor_position();

                Some(EditorMode::Visual(crate::state::VisualModeKind::normal_at(cursor_pos)))
            },
            KeyCode::Char(':') => Some(EditorMode::Command(CommandToExecute::default())),
            _ => None
        }
    }

    fn validate_request_mode_switch(&self, mode: &EditorMode) -> bool {
        match (self.state.get_mode(), mode) {
            (EditorMode::Normal, EditorMode::Insert) => true,
            (EditorMode::Normal, EditorMode::Normal) => true,
            (EditorMode::Normal, EditorMode::Visual { .. }) => true,
            (EditorMode::Normal, EditorMode::Command(_)) => true,
            (EditorMode::Insert, EditorMode::Normal) => true,
            (EditorMode::Visual { .. }, EditorMode::Normal) => true,
            (EditorMode::Command(_), EditorMode::Normal) => true,
            _ => false
        }
    }
}
